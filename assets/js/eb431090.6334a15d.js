"use strict";(self.webpackChunkcv_as_a_project_documentation=self.webpackChunkcv_as_a_project_documentation||[]).push([[2950],{4053:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>n,metadata:()=>o,toc:()=>l});var i=s(5893),a=s(1151);const n={sidebar_position:1,title:"Key Quality Attributes",tags:["quality attributes","NFR","system design","availability","throughput","scalability"]},r="Key Quality Attributes",o={id:"personal-kb/cheat-sheets/architecture-practice/system-design/key-quality-attributes",title:"Key Quality Attributes",description:"Diagram",source:"@site/docs/personal-kb/cheat-sheets/architecture-practice/system-design/key-quality-attributes.md",sourceDirName:"personal-kb/cheat-sheets/architecture-practice/system-design",slug:"/personal-kb/cheat-sheets/architecture-practice/system-design/key-quality-attributes",permalink:"/docs/personal-kb/cheat-sheets/architecture-practice/system-design/key-quality-attributes",draft:!1,unlisted:!1,editUrl:"https://github.com/aliaksandrsurma/cv-as-a-project-docs/edit/main/docs/personal-kb/cheat-sheets/architecture-practice/system-design/key-quality-attributes.md",tags:[{label:"quality attributes",permalink:"/docs/tags/quality-attributes"},{label:"NFR",permalink:"/docs/tags/nfr"},{label:"system design",permalink:"/docs/tags/system-design"},{label:"availability",permalink:"/docs/tags/availability"},{label:"throughput",permalink:"/docs/tags/throughput"},{label:"scalability",permalink:"/docs/tags/scalability"}],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1,title:"Key Quality Attributes",tags:["quality attributes","NFR","system design","availability","throughput","scalability"]},sidebar:"personalSidebar",previous:{title:"System Design",permalink:"/docs/category/system-design"},next:{title:"Example of designing REST API",permalink:"/docs/personal-kb/cheat-sheets/architecture-practice/system-design/design-rest-api-shopping-cart"}},c={},l=[];function d(e){const t={h1:"h1",img:"img",li:"li",ol:"ol",p:"p",ul:"ul",...(0,a.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h1,{id:"key-quality-attributes",children:"Key Quality Attributes"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"Diagram",src:s(178).Z+"",width:"655",height:"765"})}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"High Availability\nThis means we need to ensure a high agreed level of uptime. We often describe the design target as \u201c3 nines\u201d or \u201c4 nines\u201d. \u201c4 nines\u201d, 99.99% uptime, means the service can only be down 8.64 seconds per day."}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"To achieve high availability, we need to design redundancy in the system. There are several ways to do this:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"Hot-hot: two instances receive the same input and send the output to the downstream service. In case one side is down, the other side can immediately take over. Since both sides send output to the downstream, the downstream system needs to dedupe."}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"Hot-warm: two instances receive the same input and only the hot side sends the output to the downstream service. In case the hot side is down, the warm side takes over and starts to send output to the downstream service."}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"Single-leader cluster: one leader instance receives data from the upstream system and replicates to other replicas."}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"Leaderless cluster: there is no leader in this type of cluster. Any write will get replicated to other instances. As long as the number of write instances plus the number of read instances are larger than the total number of instances, we should get valid data."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.ol,{start:"2",children:["\n",(0,i.jsx)(t.li,{children:"High Throughput\nThis means the service needs to handle a high number of requests given a period of time. Commonly used metrics are QPS (query per second) or TPS (transaction per second)."}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"To achieve high throughput, we often add caches to the architecture so that the request can return without hitting slower I/O devices like databases or disks. We can also increase the number of threads for computation-intensive tasks. However, adding too many threads can deteriorate the performance. We then need to identify the bottlenecks in the system and increase its throughput. Using asynchronous processing can often effectively isolate heavy-lifting components."}),"\n",(0,i.jsxs)(t.ol,{start:"3",children:["\n",(0,i.jsx)(t.li,{children:"High Scalability\nThis means a system can quickly and easily extend to accommodate more volume (horizontal scalability) or more functionalities (vertical scalability). Normally we watch the response time to decide if we need to scale the system."}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,a.a)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},178:(e,t,s)=>{s.d(t,{Z:()=>i});const i=s.p+"assets/images/key-quality-attributes-4d8705151e873e7e8c8580182dc6fa3d.png"},1151:(e,t,s)=>{s.d(t,{Z:()=>o,a:()=>r});var i=s(7294);const a={},n=i.createContext(a);function r(e){const t=i.useContext(n);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),i.createElement(n.Provider,{value:t},e.children)}}}]);